[{"content":" 使用宝塔+Nginx搭建博客时，博客的404页面会被Nginx拦截替换成Nginx的默认404页面\n运行环境 CentOS 宝塔 Nginx 错误原因 宝塔默认配置的Nginx会拦截404返回的页面。\n解决方案 在宝塔页面中点击网站设置，在配置文件中的server{}下添加如下代码\n1 2 3 if (!-e $request_filename) { rewrite ^(.*)$ /index.php$1 last; } ","date":"2022-08-25T20:36:39+08:00","permalink":"https://blog.renzexuan.me/p/typecho%E7%9A%84404%E9%A1%B5%E9%9D%A2%E8%A2%ABnginx%E6%8B%A6%E6%88%AA/","title":"Typecho的404页面被nginx拦截"},{"content":" 一个拟物风的滑动Tab标签，Example：\nTab 1\nTab 2\nTab 3\nHTML代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;style.css\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;segment-control\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;tab\u0026#34; id=\u0026#34;tab-1\u0026#34; value=\u0026#34;1\u0026#34; checked /\u0026gt; \u0026lt;label for=\u0026#34;tab-1\u0026#34; class=\u0026#34;segment-control-1\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Tab 1\u0026lt;/p\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;tab\u0026#34; id=\u0026#34;tab-2\u0026#34; value=\u0026#34;2\u0026#34; /\u0026gt; \u0026lt;label for=\u0026#34;tab-2\u0026#34; class=\u0026#34;segment-control-1\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Tab 2\u0026lt;/p\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;tab\u0026#34; id=\u0026#34;tab-3\u0026#34; value=\u0026#34;3\u0026#34; /\u0026gt; \u0026lt;label for=\u0026#34;tab-3\u0026#34; class=\u0026#34;segment-control-1\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Tab 3\u0026lt;/p\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;div class=\u0026#34;segment-control-color\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; CSS代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 * { margin: 0px; padding: 0px; } html, body { width: 100%; height: 100%; } body { display: flex; align-items: center; justify-content: center; background-color: rgb(222, 231, 246); } /* .container{ display: flex; align-items: center; justify-content: center; } */ .container .segment-control { width: 300px; height: 50px; display: flex; align-items: center; border-radius: 10px; position: relative; box-shadow: 4px 4px 7px #bdc4d1, -4px -4px 7px #ffffff; } .container .segment-control #tab-2:checked ~ .segment-control-color { transition: 0.3s cubic-bezier(0.645, 0.045, 0.355, 1); transform: translate(100px); } .container .segment-control #tab-3:checked ~ .segment-control-color { transition: 0.3s cubic-bezier(0.645, 0.045, 0.355, 1); transform: translate(200px); } .container .segment-control #tab-1:checked ~ .segment-control-color { transition: 0.3s cubic-bezier(0.645, 0.045, 0.355, 1); } .container .segment-control .segment-control-color { position: absolute; width: 80px; height: 42px; border-radius: 10px; margin-left: 10px; box-shadow: inset 4px 4px 5px #bdc4d1, inset -4px -4px 5px #ffffff; } .container .segment-control label { display: flex; align-items: center; justify-content: center; margin: 0px 10px; width: 80px; height: 40px; font-size: 20px; cursor: pointer; color: rgb(162, 172, 207); } .container .segment-control label:hover { color: rgb(101, 92, 255); } .container .segment-control input { display: none; } ","date":"2022-08-25T20:36:39+08:00","permalink":"https://blog.renzexuan.me/p/%E6%BB%91%E5%8A%A8tab%E6%A0%87%E7%AD%BE/","title":"滑动Tab标签"},{"content":" 特别说明：本项目理论上试用于 各地大多数学校 的完美校园健康打卡（注意不是校内打卡），但是仅测试过 河南师范大学 ，烦请测试能用的同学留下学校信息以便后人查看，佛系更新 （这个项目本就是为了偷懒而存在的） ，有问题可以提Issues。\n功能 完美校园每日定时自动打卡\n校内打卡\n多人打卡\npushplus推送，官网\n邮箱推送\nserver酱推送（有问题），官网\n寻人启事 寻找一位熟悉Android开发或者逆向的童鞋完善此项目, https://t.me/joinchat/U1CYMWvgXjXTE9lx\n实现原理 模拟手机app登录，获取打卡所需的token\n获取上次打卡的信息，并用于自动打卡\n由于完美校园APP对登录设备的IMEI做了检测，如果是新设备只能使用短信验证码登录。而且，在高版本的Android上似乎对IMEI做了加密处理。所以，强烈建议用安装低版本Android系统的模拟器上先登录一次，再将模拟器的IMEI拷贝用作本项目的模拟登录，具体见使用方法。\n使用方法（图片显示不了，可去博客，博客地址在最下方）： 下载所需文件\nVMOS模拟器，若链接失效可去VMOS官网下载\n完美校园APP，若链接失效可去完美校园官网下载\n打开VMOS，并安装完美校园APP进行打卡\n打开VMOS，点击“+”\n选择安卓5.1极客版下载并添加\n等待一会后，会自动进入虚拟机，点击右侧小圆点\n选择文件传输\n选择“我要导入”\n导入完美校园安装包\n等待一会后，返回虚拟机，打开完美校园进行打卡\n获取虚拟机IMEI\n进入设置，注意不要选错了图标\n下滑，找到“关于手机”\n点击“状态信息”\n点击“IMEI信息”\n将IMEI信息记录备用\n点击右上角绿色按钮“Code”，选择“Download ZIP”下载压缩包\n解压压缩包会得到一个文件夹，用记事本打开文件夹中的settings.toml文本，按提示输入。\n打开腾讯云，在右上角点击登录，登陆后进入控制台，在搜索栏中搜索“云函数”\n进入云函数后，选择左侧边栏的函数服务，再点击“新建”，设置如图，点击上传将刚刚下载的文件夹\n配置触发器，图中设置为每天1点触发，可通过修改Cron表达式更改时间，具体见文档 最后点击完成，部署成功！ 个人博客地址：RZX\u0026rsquo;s blog ","date":"2022-08-25T20:36:39+08:00","permalink":"https://blog.renzexuan.me/p/%E5%AE%8C%E7%BE%8E%E6%A0%A1%E5%9B%AD%E8%87%AA%E5%8A%A8%E6%89%93%E5%8D%A1/","title":"完美校园自动打卡"},{"content":"问题描述 给定一条有向直线L以及L上的n+1个点 $x_0\u0026lt;x_1\u0026lt;\u0026hellip;\u0026lt;x_n$ 。\n有向直线L上的每个点$x_i$都有一个权$w(x_i)$;每条有向边$(x_i,x_i−1)$也都有一个非负边长$d(x_i,x_i−1)$。\n有向直线L上的每个点$x_i$可以看作客户，其服务需求量为$w(x_i)$。每条边$(x_i,x_i−1)$的边长$d(x_i,x_i−1)$可以看作运输费用。\n如果在点$x_i$处未设置服务机构，则将点$x_i$处的服务需求沿有向边转移到点$x_j$处服务机构需付出的服务转移费用为$w(x_i)∗d(x_i,x_j)$。\n在点$x_0$处已设置了服务机构，现在要在直线L上增设k处服务机构，使得整体服务转移费用最小。\n解题思路 def cost[i][j]：在$x_i$已经是服务机构的情况下，往后添加j个服务机构，$x_i$之后的点转移到服务机构的花费之和。\n例如： cost[6][2]：在服务机构$x_6$后面，再添加2个服务机构，$x_6$后所有点转移的费用和。\n由此可知：\n原问题为cost[0][k]：在$x_0$后添加k个服务机构，$x_0$后所有点转移的费用和。\ndef com[i][j]：点$x_i$移动到$x_j$的费用\n注意：com[][]只有左下角半个矩阵的秩有意义。\n递归表达式 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int m_mediaProblemOfDrectLine(int n, int k, int d[], int w[]) { int cost[n + 1][n + 1]; int com[n + 1][n + 1]; for (int i = 0; i \u0026lt; n + 1; i++) { for (int j = 0; j \u0026lt; n + 1; j++) { cost[i][j] = -1; com[i][j] = 0; } } //将cost[][]所有值都赋值为-1,将com[][]所有值都赋值为0 for (int i = 0; i \u0026lt; n + 1; i++) { for (int j = 0; j \u0026lt; i; j++) { int length = 0; for (int p = j + 1; p \u0026lt;= i; p++) { length += d[p]; } com[i][j] = w[i] * length; } } //初始化com[][]，计算左下角半个矩阵的值 for (int i = k; i \u0026lt;= n; i++) { int t = 0; for (int j = i + 1; j \u0026lt;= n; j++) { t += com[j][i]; } cost[i][0] = t; } // init cost[i][0]，将递归表达式中第一种情况赋值 for (int i = n - k; i \u0026lt;= n; i++) { cost[i][n - i] = 0; } // init cost[i][n-i]，将递归表达式中第二中情况赋值 for (int j = 1; j \u0026lt;= k; j++) { for (int i = n - j - 1; i \u0026gt;= k - j; i--) { for (int a = i + 1; a \u0026lt;= n - j; a++) {//计算cost[i][j]最小值 int t = cost[a][j - 1]; for (int b = i + 1; b \u0026lt;= a - 1; b++) { t += com[b][i]; } if (cost[i][j] == -1) { cost[i][j] = t; } else if (t \u0026lt; cost[i][j]) { cost[i][j] = t; } } } }//填写剩余的cost[i][j] return cost[0][k]; } int main() { //测试数据 // int l[] = {1, 0, 0, 0, 0, 0, 0, 0, 0, 0}; // int w[] = {0, 1, 1, 2, 1, 3, 1, 3, 2, 1}; // int d[] = {0, 1, 2, 1, 6, 2, 1, 3, 1, 2}; int n = 9; int k = 2; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;k); int d[n + 1]; d[0] = 0; int w[n + 1]; w[0] = 0; //初始化数据 for (int i = n; i \u0026gt;= 1; i--) { scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;w[i], \u0026amp;d[i]); } //读入数据 printf(\u0026#34;%d\\n\u0026#34;, m_mediaProblemOfDrectLine(n, k, d, w)); system(\u0026#34;pause\u0026#34;); return 0; } ","date":"2022-08-25T20:36:39+08:00","permalink":"https://blog.renzexuan.me/p/%E6%9C%89%E5%90%91%E7%9B%B4%E7%BA%BFm%E4%B8%AD%E5%80%BC%E9%97%AE%E9%A2%98%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","title":"有向直线`m`中值问题（动态规划）"},{"content":"问题描述 给定含有n个元素的多重集合S，每个元素在S中出现的次数成为该元素的重数。多重集S中重数最大的元素成为众数。\n例如，S={1,2,2,2,3,3,5}。多重集S的众数为2，其重数为3.\n编程任务 对于给定的由n个自然数组成的多重集S， 计算S的众数及其重数。如果出现多个众数，请输出最小的那个。\n解题思路 先对S进行排序，目的将相同的数聚集在一起，方便后续操作。\n选定数组中间的数作为界限，并以此将数组分为两部分。\n计算中间部分的众数及其众数。\n左右部分的众数及其重数，回到步骤2。\n比较三部分的众数，并选择符合题意的输出。\n写代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void swap(int \u0026amp;a, int \u0026amp;b) { int temp = a; a = b; b = temp; }//交换两个数 int partition(int num[], int l, int r) { int i = l; int j = r+1; int key = num[l]; while (true) { while (num[++i] \u0026lt;= key); while (num[--j] \u0026gt; key); if (i \u0026gt; j) { break; } swap(num[i], num[j]); } num[l] = num[j]; num[j] = key; return j; } void quicksort(int num[], int l, int r) { if (r \u0026gt; l) { int p = partition(num, l, r); quicksort(num, l, p-1); quicksort(num, p+1, r); } }//快速排序 void fun(int num[], int l, int r, int \u0026amp;mode, int \u0026amp;modeNum) { int p = (l+r)/2; int lmax = p; while (num[--lmax] == num[p]); int rmin = p; while (num[++rmin] == num[p]); //切割数组 mode = num[p]; modeNum = rmin-lmax-1; //将中间部分的众数暂定为输出结果 int lmode = 0; int lmodeNum = 0;//左众数、重数 if (lmax-l+1 \u0026gt;= modeNum) { fun(num, l, lmax, lmode, lmodeNum); }//当左半集合元素个数大于等于modeNum时才有必要考虑左半部分 if (lmodeNum \u0026gt; modeNum) { mode = lmode; modeNum = lmodeNum; } else if (lmodeNum == modeNum) { if (lmode \u0026lt; mode) { mode = lmode; } }//左众数与当前众数比较，并替换 int rmode = 0; int rmodeNum = 0;//右众数、重数 if (r-rmin+1 \u0026gt;= modeNum) { fun(num, rmin, r, rmode, rmodeNum); }//当右半集合元素个数大于等于modeNum时才有必要考虑右半部分 if (rmodeNum \u0026gt; modeNum) { mode = rmode; modeNum = rmodeNum; } else if (rmodeNum == modeNum) { if (rmode \u0026lt; mode) { mode = rmode; } }//右众数与当前众数比较，并替换 } int main() { int num[28]={2,2,3,3,3,1,1,1,1,6,6,6,4,4,4,5,5,2,2,3,4,4,6,6,3,5,5,5}; quicksort(num, 0, 28); int mode, modeNum; fun(num, 0, 28, mode, modeNum); printf(\u0026#34;%d, %d\u0026#34;, mode, modeNum); system(\u0026#34;pause\u0026#34;); return 0; } ","date":"2022-08-25T20:36:39+08:00","permalink":"https://blog.renzexuan.me/p/%E4%BC%97%E6%95%B0%E9%97%AE%E9%A2%98%E5%88%86%E6%B2%BB%E6%B3%95/","title":"众数问题（分治法）"},{"content":"问题描述 设I是一个n位十进制整数。如果将I划分为k段，则可得到k个整数。\n这k个整数的乘积称为I的一个k乘积。\n编程任务 试设计一个算法，对于给定的I和k，求出I的最大k乘积。\n解题思路 证明该问题满足最优子结构 假设数I的最大k乘积为f(I, k)，其对应划分方法的最后一段其值为α，前k-1段的为β，乘积为g(β, k-1)，f(I, k) = α × g(β, k-1)。\n则要求，g(β, k-1)为β的最大k-1乘积。\n否则，必然存在h(β, k-1) \u0026gt; g(β, k-1) 使得 α × h(β, k-1) \u0026gt; α × g(β, k-1)既α × h(β, k-1) \u0026gt; f(I, k)。\n∴ f(I, k)不是I的最大k乘积，与假设违背。\n综上所述：最大k乘积满足最优子结构\n写代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int n; int k; int num[10]; int dp[10][10]; int m[10][10]; void init() { for (int i = 1; i \u0026lt;= n; i++) { m[i][i] = num[i]; } for (int i = 1; i \u0026lt;= n; i++) { for (int j = i+1; j \u0026lt;= n; j++) { m[i][j] = m[i][j-1]*10 + m[j][j]; } } }//初始化 int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); scanf(\u0026#34;%d\u0026#34;, \u0026amp;k); for (int i=1; i \u0026lt;= n; i++) { char ch; scanf(\u0026#34;%s\u0026#34;, \u0026amp;ch); num[i] = ch-\u0026#39;0\u0026#39;; } init(); for (int i = 1; i \u0026lt;= n; i++) { for(int j = 0; j \u0026lt; i; j++) { if(j == 0) { dp[i][j] = m[1][i]; continue; } for(int k = 1; k \u0026lt; i; k++) { if (dp[i][j] \u0026lt; dp[k][j-1]*m[k+1][i]) { dp[i][j] = dp[k][j-1]*m[k+1][i]; } } } } printf(\u0026#34;%d\\n\u0026#34;, dp[n][k-1]); system(\u0026#34;pause\u0026#34;); return 0; } ","date":"2022-08-25T20:36:39+08:00","permalink":"https://blog.renzexuan.me/p/%E6%9C%80%E5%A4%A7k%E4%B9%98%E7%A7%AF%E9%97%AE%E9%A2%98/","title":"最大k乘积问题"}]